/*! @file GPMF_demo.c
 *
 *  @brief Demo to extract GPMF from an MP4
 *
 *  @version 2.4.0
 *
 *  (C) Copyright 2017-2020 GoPro Inc (http://gopro.com/).
 *
 *  Licensed under either:
 *  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0
 *  - MIT license, http://opensource.org/licenses/MIT
 *  at your option.
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>

#include "../GPMF_parser.h"
#include "GPMF_mp4reader.h"
#include "../GPMF_utils.h"

typedef enum {
    ACCL,
    GYRO,
    GPS5,
    GPS9
} SensorOption;

char option[] = "GPS9"; // Declare and initialize a string

#define	SHOW_VIDEO_FRAMERATE		1
#define	SHOW_PAYLOAD_TIME			1
#define	SHOW_ALL_PAYLOADS			0
#define SHOW_GPMF_STRUCTURE			0
#define	SHOW_PAYLOAD_INDEX			0
#define	SHOW_SCALED_DATA			1
#define	SHOW_THIS_FOUR_CC			STR2FOURCC(option)
#define SHOW_COMPUTED_SAMPLERATES	1

// Define the fourCC for sample rate
#define GPMF_KEY_SAMPLERATE STR2FOURCC("SRAT")

extern void PrintGPMF(GPMF_stream* ms);

void printHelp(char* name)
{
	printf("usage: %s <file_with_GPMF> <optional features>\n", name);
	printf("       -a - %s all payloads\n", SHOW_ALL_PAYLOADS ? "disable" : "show");
	printf("       -g - %s GPMF structure\n", SHOW_GPMF_STRUCTURE ? "disable" : "show");
	printf("       -i - %s index of the payload\n", SHOW_PAYLOAD_INDEX ? "disable" : "show");
	printf("       -s - %s scaled data\n", SHOW_SCALED_DATA ? "disable" : "show");
	printf("       -c - %s computed sample rates\n", SHOW_COMPUTED_SAMPLERATES ? "disable" : "show");
	printf("       -v - %s video framerate\n", SHOW_VIDEO_FRAMERATE ? "disable" : "show");
	printf("       -t - %s time of the payload\n", SHOW_PAYLOAD_TIME ? "disable" : "show");
	printf("       -fWXYZ - show only this fourCC , e.g. -f%c%c%c%c (default) just -f for all\n", PRINTF_4CC(SHOW_THIS_FOUR_CC));
	printf("       -h - this help\n");
	printf("       \n");
	printf("       ver 2.0\n");
}

int main(int argc, char* argv[])
{
	GPMF_ERR ret = GPMF_OK;
	GPMF_stream metadata_stream, * ms = &metadata_stream;
	double metadatalength;
	uint32_t* payload = NULL;
	uint32_t payloadsize = 0;
	size_t payloadres = 0;

	uint32_t show_all_payloads = SHOW_ALL_PAYLOADS;
	uint32_t show_gpmf_structure = SHOW_GPMF_STRUCTURE;
	uint32_t show_payload_index = SHOW_PAYLOAD_INDEX;
	uint32_t show_scaled_data = SHOW_SCALED_DATA;
	uint32_t show_computed_samplerates = SHOW_COMPUTED_SAMPLERATES;
	uint32_t show_video_framerate = SHOW_VIDEO_FRAMERATE;
	uint32_t show_payload_time = SHOW_PAYLOAD_TIME;
	uint32_t show_this_four_cc = SHOW_THIS_FOUR_CC;

	// get file return data
	if (argc < 2)
	{
		printHelp(argv[0]);
		return -1;
	}

#if 1 // Search for GPMF Track
	size_t mp4handle = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE, 0);
#else // look for a global GPMF payload in the moov header, within 'udta'
	size_t mp4handle = OpenMP4SourceUDTA(argv[1], 0);  //Search for GPMF payload with MP4's udta
#endif
	if (mp4handle == 0)
	{
		printf("error: %s is an invalid MP4/MOV or it has no GPMF data\n\n", argv[1]);

		printHelp(argv[0]);
		return -1;
	}

	for (int i = 2; i < argc; i++)
	{
		if (argv[i][0] == '-') //feature switches
		{
			switch (argv[i][1])
			{
			case 'a': show_all_payloads ^= 1;				break;
			case 'g': show_gpmf_structure ^= 1;				break;
			case 'i': show_payload_index ^= 1;				break;
			case 's': show_scaled_data ^= 1;				break;
			case 'c': show_computed_samplerates ^= 1;		break;
			case 'v': show_video_framerate ^= 1;			break;
			case 't': show_payload_time ^= 1;				break;
			case 'f': show_this_four_cc = STR2FOURCC((&(argv[i][2])));  break;
			case 'h': printHelp(argv[0]);  break;
			}
		}
	}


	metadatalength = GetDuration(mp4handle);

	if (metadatalength > 0.0)
	{
		SensorOption option = GPS9; // Replace with the user's choice

		switch(option) {
			case ACCL:
				printf("acceleration m/s^2 X,acceleration m/s^2 Y,acceleration m/s^2 Z,Initial time [seg],Ending time [seg]\n");
				break;
			case GYRO:
				printf("Gyro -Y [rad/s],X [rad/s],Z [rad/s],Initial time [seg],Ending time [seg]\n");
				break;
			case GPS5:
				printf("GPS (Lat.) [deg],GPS (Long.) [deg],GPS (Alt.) [m],GPS (2D) [m/s],GPS (3D) [m/s],Initial time [seg],Ending time [seg]\n");
				break;
			case GPS9:
				printf("GPS (Lat.) [deg],GPS (Long.) [deg],GPS (Alt.) [m],GPS (2D) [m/s],GPS (3D) [m/s],GPS (days) [deg],GPS (secs) [s],GPS (DOP) [deg],GPS (fix) [deg],Initial time [seg],Ending time [seg]\n");
				break;
			default:
				printf("Invalid option\n");
		}

		uint32_t index, payloads = GetNumberPayloads(mp4handle);
		//printf("found %.2fs of metadata, from %d payloads, within %s\n", metadatalength, payloads, argv[1]);

		uint32_t fr_num, fr_dem;
		uint32_t frames = GetVideoFrameRateAndCount(mp4handle, &fr_num, &fr_dem);
		if (show_video_framerate)
		{
			if (frames)
			{
				//printf("VIDEO FRAMERATE:\n  %.3f with %d frames\n", (float)fr_num / (float)fr_dem, frames);
			}
		}

		//loop throguh all the payloads
		for (index = 0; index < payloads; index++)
		{
			double in = 0.0, out = 0.0; //times
			payloadsize = GetPayloadSize(mp4handle, index);
			payloadres = GetPayloadResource(mp4handle, payloadres, payloadsize);
			payload = GetPayload(mp4handle, payloadres, index);
			if (payload == NULL)
				goto cleanup;

			ret = GetPayloadTime(mp4handle, index, &in, &out);
			if (ret != GPMF_OK)
				goto cleanup;

			ret = GPMF_Init(ms, payload, payloadsize);
			if (ret != GPMF_OK)
				goto cleanup;

			if (show_payload_time)
				if (show_gpmf_structure || show_payload_index || show_scaled_data)
					if (show_all_payloads || index == 0)
						//printf("PAYLOAD TIME:\n  %.3f to %.3f seconds\n", in, out);

			if (show_payload_index)
				if (show_gpmf_structure || show_payload_index || show_scaled_data)
					if (show_all_payloads || index == 0)
						//printf("PAYLOAD INDEX:\n  %d of %d\n", index, payloads);

			if (show_gpmf_structure)
			{
				if (show_all_payloads || index == 0)
				{
					//printf("GPMF STRUCTURE:\n");
					//Output metadata and any nesting
					PrintGPMF(ms);
				}
			}

			if (show_scaled_data)
			{
				// Start the GPMF parsing

				if (show_all_payloads || index == 0)
				{
					//find the first fourCC within the payload
					if (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))
					{
						do
						{
							if (show_this_four_cc == 0 || show_this_four_cc == GPMF_Key(ms))
							{
								GPMF_stream find_stream;
								double approx_period = 0.0;
								uint32_t samples = 0;
								uint32_t currentSamples = GPMF_Repeat(ms);
								uint32_t currentSampleBytes = GPMF_StructSize(ms);

								//create a temporary parsing state
								GPMF_CopyState(ms, &find_stream);

								//find next fourCC contained within, if present
								if (GPMF_OK == GPMF_FindNext(&find_stream, GPMF_KEY_SAMPLERATE, GPMF_RECURSE_LEVELS))
								{
									approx_period = 1.0 / GPMF_InterperateSampleRate(find_stream, &approx_period);
								}

								if (currentSamples && currentSampleBytes)
								{
									switch (GPMF_Key(ms))
									{
									case STR2FOURCC("ACCL"):
									{
										if (show_this_four_cc == 0 || show_this_four_cc == GPMF_Key(ms))
										{
											if (option == ACCL) // Print only if the selected option is ACCL
											{
												int32_t* data;
												uint32_t elements = currentSampleBytes / sizeof(int32_t);
												uint32_t elementsperSample = elements / currentSamples;
												uint32_t i, j;

												data = (int32_t*)malloc(elements * sizeof(int32_t));
												GPMF_ScaledData(ms, data, currentSamples, 0, GPMF_TYPE_COMPLEX | GPMF_TYPE_SIGNED);

												for (i = 0; i < currentSamples; i++)
												{
													for (j = 0; j < elementsperSample; j++)
													{
														float scaled_value = (float)data[i * elementsperSample + j] * GPMF_SCALE_DEC;
														printf("%f", scaled_value);

														if (j < elementsperSample - 1)
															printf(", ");
													}

													printf(", %.3f, %.3f\n", in, out);
												}

												free(data);
											}
										}
										break;
									}

									case STR2FOURCC("GYRO"):
									{
										if (show_this_four_cc == 0 || show_this_four_cc == GPMF_Key(ms))
										{
											if (option == GYRO) // Print only if the selected option is GYRO
											{
												int32_t* data;
												uint32_t elements = currentSampleBytes / sizeof(int32_t);
												uint32_t elementsperSample = elements / currentSamples;
												uint32_t i, j;

												data = (int32_t*)malloc(elements * sizeof(int32_t));
												GPMF_ScaledData(ms, data, currentSamples, 0, GPMF_TYPE_COMPLEX | GPMF_TYPE_SIGNED);

												for (i = 0; i < currentSamples; i++)
												{
													for (j = 0; j < elementsperSample; j++)
													{
														float scaled_value = (float)data[i * elementsperSample + j] * GPMF_SCALE_DEC;
														printf("%f", scaled_value);

														if (j < elementsperSample - 1)
															printf(", ");
													}

													printf(", %.3f, %.3f\n", in, out);
												}

												free(data);
											}
										}
										break;
									}

									case STR2FOURCC("GPS5"):
									{
										if (show_this_four_cc == 0 || show_this_four_cc == GPMF_Key(ms))
										{
											if (option == GPS5) // Print only if the selected option is GPS5
											{
												int32_t* data;
												uint32_t elements = currentSampleBytes / sizeof(int32_t);
												uint32_t elementsperSample = elements / currentSamples;
												uint32_t i, j;

												data = (int32_t*)malloc(elements * sizeof(int32_t));
												GPMF_ScaledData(ms, data, currentSamples, 0, GPMF_TYPE_COMPLEX | GPMF_TYPE_SIGNED);

												for (i = 0; i < currentSamples; i++)
												{
													for (j = 0; j < elementsperSample; j++)
													{
														float scaled_value = (float)data[i * elementsperSample + j] * GPMF_SCALE_DEC;
														printf("%f", scaled_value);

														if (j < elementsperSample - 1)
															printf(", ");
													}

													printf(", %.3f, %.3f\n", in, out);
												}

												free(data);
											}
										}
										break;
									}

									case STR2FOURCC("GPS9"):
									{
										if (show_this_four_cc == 0 || show_this_four_cc == GPMF_Key(ms))
										{
											if (option == GPS9) // Print only if the selected option is GPS9
											{
												int32_t* data;
												uint32_t elements = currentSampleBytes / sizeof(int32_t);
												uint32_t elementsperSample = elements / currentSamples;
												uint32_t i, j;

												data = (int32_t*)malloc(elements * sizeof(int32_t));
												GPMF_ScaledData(ms, data, currentSamples, 0, GPMF_TYPE_COMPLEX | GPMF_TYPE_SIGNED);

												for (i = 0; i < currentSamples; i++)
												{
													for (j = 0; j < elementsperSample; j++)
													{
														float scaled_value = (float)data[i * elementsperSample + j] * GPMF_SCALE_DEC;
														printf("%f", scaled_value);

														if (j < elementsperSample - 1)
															printf(", ");
													}

													printf(", %.3f, %.3f\n", in, out);
												}

												free(data);
											}
										}
										break;
									}

									default:
										break;
									}
								}
							}
						} while (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS));
					}
				}
			}
		}

	cleanup:
		if (payload) FreePayloadResource(mp4handle, payloadres);
		CloseSource(mp4handle);
	}

	return ret;
}
