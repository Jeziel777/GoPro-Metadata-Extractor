from flask import Flask, render_template, request, redirect, url_for, jsonify, send_from_directory
from flask_wtf import FlaskForm
from wtforms import FileField, SubmitField
from werkzeug.utils import secure_filename
import os
import subprocess

from wtforms.validators import InputRequired

base_dir = os.path.abspath(os.path.dirname(__file__))

# Initialize the Flask application
app = Flask(__name__)
# Configure the secret key for session management and the upload folder path
app.config['SECRET_KEY'] = 'pavAnalitics456'
app.config['UPLOAD_FOLDER'] = 'static/files'

app.config['GPMF_PARSER'] = os.path.join(base_dir, 'C-code', 'csv_extractor', 'gpmf-parser.exe')



# Ensure the upload folder exists
if not os.path.exists(app.config['UPLOAD_FOLDER']):
    os.makedirs(app.config['UPLOAD_FOLDER'])

# Define a form class for file upload using Flask-WTF
class UploadFileForm(FlaskForm):
    file = FileField("File", validators=[InputRequired()])  # File input field with a required validator
    submit = SubmitField("Upload file")  # Submit button

# Function to process the uploaded video file using gpmf-parser
def process_video_file(video_file_path):
    c_program_path = app.config['GPMF_PARSER']
    subprocess.run([c_program_path, video_file_path], check=True)

# Function to process the CSV files using a Python script
def process_csv_files(csv_files):
    python_script_path = "process_csv.py"
    final_csv_files = []
    for csv_file in csv_files:
        print(f"Processing CSV file: {csv_file}")  # Print the path of the CSV file
        try:
            subprocess.run(["python3", python_script_path, csv_file], check=True)
            final_csv_file = csv_file[:-4] + "_final.csv"
            final_csv_files.append(final_csv_file)
            print(f"Processed CSV file saved to: {final_csv_file}")  # Confirm the file was processed
        except subprocess.CalledProcessError as e:
            print(f"Error processing {csv_file}: {e}")
    return final_csv_files

# Add this function to send the requested file
@app.route('/download/<filename>', methods=['GET'])
def download_file(filename):
    print(f"Requested file: {filename}")  # Print the requested filename
    directory = app.config['UPLOAD_FOLDER']
    file_path = os.path.join(directory, filename)
    if os.path.isfile(file_path):
        print(f"File exists: {file_path}")  # Confirm the file exists
        return send_from_directory(directory, filename)
    else:
        print(f"File not found: {file_path}")  # Indicate the file was not found
        return jsonify({'error': 'File not found'}), 404

# Modify the home route to return the CSV file paths
@app.route('/', methods=['GET', 'POST'])
@app.route('/home', methods=['GET', 'POST'])
def home():
    form = UploadFileForm()  # Create an instance of the file upload form
    if form.validate_on_submit():  # Check if the form has been submitted and is valid
        file = form.file.data  # Get the uploaded file from the form
        filename = secure_filename(file.filename)  # Secure the filename
        if not filename.lower().endswith('.mp4'):
            return jsonify({'error': 'Invalid file type. Only MP4 files are allowed.'}), 400

        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)  # Create the full file path
        file.save(file_path)  # Save the uploaded file to the specified path
        print(f"Uploaded file saved to: {file_path}")  # Confirm the file was saved

        try:
            process_video_file(file_path)  # Process the video file using gpmf-parser
            # Define the expected CSV files generated by gpmf-parser
            csv_files = [
                f"{file_path}_ACCL_sample.csv",
                f"{file_path}_GYRO_sample.csv",
                f"{file_path}_GPS9_sample.csv"
            ]
            final_csv_files = process_csv_files(csv_files)  # Process the CSV files using the Python script

            csv_filenames = [os.path.basename(csv_file) for csv_file in final_csv_files]
            return jsonify({'filename': filename, 'csv_files': csv_filenames})  # Return the filenames as a JSON response
        except subprocess.CalledProcessError as e:  # Handle any errors that occur during processing
            return jsonify({'error': str(e)}), 500  # Return an error message as a JSON response

    return render_template('index.html', form=form)  # Render the upload form template

# Run the Flask application in debug mode
if __name__ == '__main__':
    app.run()
